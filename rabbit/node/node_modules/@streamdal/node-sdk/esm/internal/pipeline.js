var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { TailRequestType } from "@streamdal/protos/protos/sp_common";
import { audienceKey, internal } from "./register.js";
export const initPipelines = (configs) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        console.debug("initializing pipelines");
        const { response } = yield configs.grpcClient.getAttachCommandsByService({
            serviceName: configs.serviceName.toLowerCase(),
        }, { meta: { "auth-token": configs.streamdalToken } });
        for (const [k, v] of Object.entries(response.wasmModules)) {
            internal.wasmModules.set(k, v);
        }
        for (const command of response.active) {
            processResponse(command);
        }
        internal.pipelineInitialized = true;
    }
    catch (e) {
        console.error("Error initializing pipelines", e);
    }
});
export const processResponse = (response) => {
    if (!response.audience) {
        response.command.oneofKind !== "keepAlive" &&
            console.debug("command response has no audience, ignoring");
        return;
    }
    switch (response.command.oneofKind) {
        case "attachPipeline":
            response.command.attachPipeline.pipeline &&
                attachPipeline(response.audience, response.command.attachPipeline.pipeline);
            break;
        case "detachPipeline":
            detachPipeline(response.audience, response.command.detachPipeline.pipelineId);
            break;
        case "pausePipeline":
            togglePausePipeline(response.audience, response.command.pausePipeline.pipelineId, true);
            break;
        case "resumePipeline":
            togglePausePipeline(response.audience, response.command.resumePipeline.pipelineId, false);
            break;
        case "tail":
            tailPipeline(response.audience, response.command.tail);
            break;
    }
};
export const buildPipeline = (pipeline) => (Object.assign(Object.assign({}, pipeline), { steps: pipeline.steps.map((step) => {
        var _a;
        return (Object.assign(Object.assign({}, step), (step.WasmId
            ? { WasmBytes: (_a = internal.wasmModules.get(step.WasmId)) === null || _a === void 0 ? void 0 : _a.bytes }
            : {})));
    }) }));
export const attachPipeline = (audience, pipeline) => pipeline.name !== "Schema Inference" &&
    internal.pipelines.set(audienceKey(audience), Object.assign(Object.assign({}, buildPipeline(pipeline)), { paused: false }));
export const detachPipeline = (audience, pipelineId) => {
    const key = audienceKey(audience);
    const p = internal.pipelines.get(key);
    pipelineId === (p === null || p === void 0 ? void 0 : p.id) && internal.pipelines.delete(key);
};
export const togglePausePipeline = (audience, pipelineId, paused) => {
    const key = audienceKey(audience);
    const p = internal.pipelines.get(key);
    pipelineId === (p === null || p === void 0 ? void 0 : p.id) && internal.pipelines.set(key, Object.assign(Object.assign({}, p), { paused }));
};
export const tailPipeline = (audience, { request }) => {
    var _a, _b;
    console.debug("received a tail command for audience", audience);
    if (!request) {
        console.debug("no tail reqeuest details specified, skipping");
        return;
    }
    switch (request.type) {
        case TailRequestType.START: {
            console.debug("received a START tail: adding entry to audiences for tail id", audience);
            // Create inner map if it doesn't exist
            if (!internal.audiences.has(audienceKey(audience))) {
                internal.audiences.set(audienceKey(audience), {
                    audience,
                    tails: new Map(),
                });
            }
            // Add entry (@JH, OK if overwritten?)
            request.Id &&
                ((_a = internal.audiences.get(audienceKey(audience))) === null || _a === void 0 ? void 0 : _a.tails.set(request.Id, {
                    tail: request.type === TailRequestType.START,
                    tailRequestId: request.Id,
                }));
            break;
        }
        case TailRequestType.STOP: {
            console.debug("received a STOP tail: removing entry from audiences for tail id", request.Id);
            request.Id &&
                ((_b = internal.audiences.get(audienceKey(audience))) === null || _b === void 0 ? void 0 : _b.tails.delete(request.Id));
            break;
        }
        default:
            console.error("unknown tail request type ", request.type);
            break;
    }
};
