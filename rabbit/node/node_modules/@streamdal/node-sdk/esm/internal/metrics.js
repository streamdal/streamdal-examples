var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { OperationType, } from "@streamdal/protos/protos/sp_common";
import ReadWriteLock from "rwlock";
export const METRIC_INTERVAL = 1000;
export const metrics = new Map();
export const lock = new ReadWriteLock();
export const getStepLabels = (audience, stepStatus) => ({
    service: audience.serviceName,
    component: audience.componentName,
    operation: audience.operationName,
    pipeline_id: stepStatus.pipelineId,
    pipeline_name: stepStatus.pipelineName,
});
export const stepMetrics = (audience, stepStatus, payloadSize
// eslint-disable-next-line @typescript-eslint/require-await
) => __awaiter(void 0, void 0, void 0, function* () {
    lock.writeLock((release) => {
        var _a, _b, _c, _d, _e, _f;
        const opName = audience.operationType === OperationType.CONSUMER ? "consume" : "produce";
        const labels = getStepLabels(audience, stepStatus);
        const stepErrorKey = `counter_${opName}_errors`;
        const stepProcessedKey = `counter_${opName}_processed`;
        const stepBytesKey = `counter_${opName}_bytes`;
        stepStatus.error &&
            metrics.set(stepErrorKey, {
                name: stepErrorKey,
                value: ((_b = (_a = metrics.get(stepErrorKey)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + 1,
                labels,
                audience,
            });
        metrics.set(stepProcessedKey, {
            name: stepProcessedKey,
            value: ((_d = (_c = metrics.get(stepProcessedKey)) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 0) + 1,
            labels,
            audience,
        });
        metrics.set(stepBytesKey, {
            name: stepBytesKey,
            value: ((_f = (_e = metrics.get(stepBytesKey)) === null || _e === void 0 ? void 0 : _e.value) !== null && _f !== void 0 ? _f : 0) + payloadSize,
            labels,
            audience,
        });
        release();
    });
});
export const audienceMetrics = (audience, payloadSize
// eslint-disable-next-line @typescript-eslint/require-await
) => __awaiter(void 0, void 0, void 0, function* () {
    lock.writeLock((release) => {
        var _a, _b, _c, _d;
        const opName = audience.operationType === OperationType.CONSUMER ? "consume" : "produce";
        const bytesProcessedKey = `counter_${opName}_bytes_rate`;
        const processedKey = `counter_${opName}_processed_rate`;
        metrics.set(bytesProcessedKey, {
            name: bytesProcessedKey,
            value: ((_b = (_a = metrics.get(bytesProcessedKey)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + payloadSize,
            labels: {},
            audience,
        });
        metrics.set(processedKey, {
            name: processedKey,
            value: ((_d = (_c = metrics.get(processedKey)) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 0) + 1,
            labels: {},
            audience,
        });
        release();
    });
});
export const sendMetrics = (configs) => lock.writeLock((release) => {
    try {
        if (!metrics.size) {
            console.debug(`### no metrics found, skipping`);
            release();
            return;
        }
        const metricsData = Array.from(metrics.values()).map((m) => (Object.assign(Object.assign({}, m), { 
            //
            // Make sure we always send data per second
            value: m.value / (METRIC_INTERVAL / 1000) })));
        console.debug("sending metrics", metricsData);
        void configs.grpcClient.metrics({
            metrics: metricsData,
        }, { meta: { "auth-token": configs.streamdalToken } });
        metrics.clear();
    }
    catch (e) {
        console.error("error sending metrics", e);
    }
    release();
});
