"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exampleStaggeredMultipleComponentsPerServiceAndPerGroup = exports.exampleSimple = exports.exampleMultipleComponentsPerService = exports.exampleMultipleGroup = exports.exampleConcurrent = exports.tailFast = exports.throughputFriendly = exports.highVolumeTail = exports.tailFriendly = exports.exampleStaggered = void 0;
const streamdal_js_1 = require("../streamdal.js");
const exampleData = {
    boolean_t: true,
    boolean_f: false,
    object: {
        ipv4_address: "127.0.0.1",
        ipv6_address: "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
        mac_address: "00-B0-D0-63-C2-26",
        uuid_dash: "550e8400-e29b-41d4-a716-446655440000",
        uuid_colon: "550e8400:e29b:41d4:a716:446655440000",
        uuid_stripped: "550e8400e29b41d4a716446655440000",
        number_as_string: "1234",
        field: "value",
        empty_string: "",
        null_field: null,
        empty_array: [],
    },
    array: ["value1", "value2"],
    number_int: 100,
    number_float: 100.1,
    timestamp_unix_str: "1614556800",
    timestamp_unix_num: 1614556800,
    timestamp_unix_nano_str: "1614556800000000000",
    timestamp_unix_nano_num: 1614556800000000000,
    timestamp_rfc3339: "2023-06-29T12:34:56Z",
};
const serviceAConfig = {
    streamdalUrl: "localhost:9090",
    streamdalToken: "1234",
    serviceName: "test-service",
    pipelineTimeout: "100",
    stepTimeout: "10",
    dryRun: false,
};
const serviceBConfig = {
    streamdalUrl: "localhost:9090",
    streamdalToken: "1234",
    serviceName: "another-test-service",
    pipelineTimeout: "100",
    stepTimeout: "10",
    dryRun: false,
};
const serviceCConfig = {
    streamdalUrl: "localhost:9090",
    streamdalToken: "1234",
    serviceName: "third-service",
    pipelineTimeout: "100",
    stepTimeout: "10",
    dryRun: false,
};
const audienceAConsumer = {
    serviceName: "test-service",
    componentName: "kafka",
    operationType: streamdal_js_1.OperationType.CONSUMER,
    operationName: "kafka-consumer",
};
const audienceAProducer = {
    serviceName: "test-service",
    componentName: "kafka",
    operationType: streamdal_js_1.OperationType.PRODUCER,
    operationName: "kafka-producer",
};
const audienceBConsumer = {
    serviceName: "another-test-service",
    componentName: "another-kafka",
    operationType: streamdal_js_1.OperationType.CONSUMER,
    operationName: "test-kafka-consumer",
};
const audienceBProducer = {
    serviceName: "another-test-service",
    componentName: "another-kafka",
    operationType: streamdal_js_1.OperationType.PRODUCER,
    operationName: "test-kafka-producer",
};
const audienceCConsumer = {
    serviceName: "third-service",
    componentName: "third-kafka",
    operationType: streamdal_js_1.OperationType.CONSUMER,
    operationName: "kafka-consumer",
};
const audienceCProducer = {
    serviceName: "third-service",
    componentName: "third-kafka",
    operationType: streamdal_js_1.OperationType.PRODUCER,
    operationName: "kafka-consumer",
};
const logTest = (streamdal, audience, input) => __awaiter(void 0, void 0, void 0, function* () {
    console.log("--------------------------------");
    console.log(new Date());
    console.log(`sending pipeline request for ${audience.serviceName} - ${streamdal_js_1.OperationType[audience.operationType].toLowerCase()}`);
    const { error, message, data } = yield streamdal.processPipeline({
        audience: audience,
        data: new TextEncoder().encode(JSON.stringify(input)),
    });
    console.log("error", error);
    console.log("message", message);
    console.log("data:");
    try {
        data && data.length > 0
            ? console.dir(JSON.parse(new TextDecoder().decode(data)), { depth: 20 })
            : console.log("no data returned");
    }
    catch (e) {
        console.error("could not parse data", e);
    }
    console.log("pipeline request done");
    console.log("--------------------------------");
    console.log("\n");
});
const randomInterval = (streamdal, audience, input) => __awaiter(void 0, void 0, void 0, function* () {
    console.log("--------------------------------");
    console.log(new Date());
    console.log(`sending pipeline request for ${audience.serviceName} - ${streamdal_js_1.OperationType[audience.operationType].toLowerCase()}`);
    const { error, message, data } = yield streamdal.processPipeline({
        audience: audience,
        data: new TextEncoder().encode(JSON.stringify(input)),
    });
    console.log("error", error);
    console.log("message", message);
    console.log("data:");
    try {
        data && data.length > 0
            ? console.dir(JSON.parse(new TextDecoder().decode(data)), { depth: 20 })
            : console.log("no data returned");
    }
    catch (e) {
        console.error("could not parse data", e);
    }
    console.log("pipeline request done");
    console.log("--------------------------------");
    console.log("\n");
    setTimeout(
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    () => randomInterval(streamdal, audience, input), Math.floor(Math.random() * (3000 - 250) + 3000));
});
// eslint-disable-next-line @typescript-eslint/require-await
const exampleStaggered = () => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalA = new streamdal_js_1.Streamdal(serviceAConfig);
    const streamdalB = new streamdal_js_1.Streamdal(serviceBConfig);
    setInterval(() => {
        void randomInterval(streamdalA, audienceAConsumer, exampleData);
    }, 2000);
    setTimeout(() => {
        void logTest(streamdalA, audienceAProducer, exampleData);
    }, 4000);
    setTimeout(() => {
        void logTest(streamdalB, audienceBConsumer, exampleData);
    }, 8000);
    setTimeout(() => {
        void logTest(streamdalB, audienceBProducer, exampleData);
    }, 12000);
});
exports.exampleStaggered = exampleStaggered;
// eslint-disable-next-line @typescript-eslint/require-await
const tailFriendly = () => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalA = new streamdal_js_1.Streamdal(serviceAConfig);
    const streamdalB = new streamdal_js_1.Streamdal(serviceBConfig);
    void logTest(streamdalA, audienceAConsumer, exampleData);
    void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { operationName: "kafka-consumer-two" }), exampleData);
    void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { operationName: "kafka-consumer-three" }), exampleData);
    void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { componentName: "another-kafka" }), exampleData);
    void logTest(streamdalA, audienceAProducer, exampleData);
    setInterval(() => {
        void logTest(streamdalB, audienceBConsumer, exampleData);
    }, 1000);
    void logTest(streamdalB, audienceBProducer, exampleData);
    void logTest(streamdalB, Object.assign(Object.assign({}, audienceBProducer), { componentName: "kafka" }), exampleData);
});
exports.tailFriendly = tailFriendly;
// eslint-disable-next-line @typescript-eslint/require-await
const highVolumeTail = () => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalA = new streamdal_js_1.Streamdal(serviceAConfig);
    const streamdalB = new streamdal_js_1.Streamdal(serviceBConfig);
    setInterval(() => {
        void logTest(streamdalA, audienceAConsumer, exampleData);
    }, 500);
    setInterval(() => {
        void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { operationName: "kafka-consumer-two" }), exampleData);
    }, 500);
    setInterval(() => {
        void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { operationName: "kafka-consumer-three" }), exampleData);
    }, 1000);
    setInterval(() => {
        void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { componentName: "another-kafka" }), exampleData);
    }, 500);
    void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { componentName: "another-kafka" }), exampleData);
    setInterval(() => {
        void logTest(streamdalA, audienceAProducer, exampleData);
    }, 2000);
    setInterval(() => {
        void logTest(streamdalB, audienceBConsumer, exampleData);
    }, 250);
    setInterval(() => {
        void logTest(streamdalB, audienceBProducer, exampleData);
    }, 500);
    setInterval(() => {
        void logTest(streamdalB, Object.assign(Object.assign({}, audienceBProducer), { componentName: "kafka" }), exampleData);
    }, 500);
});
exports.highVolumeTail = highVolumeTail;
// eslint-disable-next-line @typescript-eslint/require-await
const throughputFriendly = () => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalA = new streamdal_js_1.Streamdal(serviceAConfig);
    const streamdalB = new streamdal_js_1.Streamdal(serviceBConfig);
    void randomInterval(streamdalA, audienceAConsumer, exampleData);
    void randomInterval(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { operationName: "kafka-consumer-two" }), exampleData);
    void randomInterval(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { operationName: "kafka-consumer-three" }), exampleData);
    void randomInterval(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { componentName: "another-kafka" }), exampleData);
    void randomInterval(streamdalA, audienceAProducer, exampleData);
    void randomInterval(streamdalB, audienceBConsumer, exampleData);
    void randomInterval(streamdalB, audienceBProducer, exampleData);
    void randomInterval(streamdalB, Object.assign(Object.assign({}, audienceBProducer), { componentName: "kafka" }), exampleData);
});
exports.throughputFriendly = throughputFriendly;
// eslint-disable-next-line @typescript-eslint/require-await
const tailFast = () => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalB = new streamdal_js_1.Streamdal(serviceBConfig);
    setInterval(() => {
        void logTest(streamdalB, audienceBConsumer, exampleData);
    }, 100);
});
exports.tailFast = tailFast;
// eslint-disable-next-line @typescript-eslint/require-await
const exampleConcurrent = () => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalA = new streamdal_js_1.Streamdal(serviceAConfig);
    const streamdalB = new streamdal_js_1.Streamdal(serviceBConfig);
    setInterval(() => {
        void logTest(streamdalA, audienceAConsumer, exampleData);
    }, 4000);
    void logTest(streamdalA, audienceAProducer, exampleData);
    void logTest(streamdalB, audienceBConsumer, exampleData);
    void logTest(streamdalB, audienceBProducer, exampleData);
});
exports.exampleConcurrent = exampleConcurrent;
// eslint-disable-next-line @typescript-eslint/require-await
const exampleMultipleGroup = () => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalA = new streamdal_js_1.Streamdal(serviceAConfig);
    const streamdalB = new streamdal_js_1.Streamdal(serviceBConfig);
    void logTest(streamdalA, audienceAConsumer, exampleData);
    void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { operationName: "kafka-consumer-two" }), exampleData);
    void logTest(streamdalA, audienceAProducer, exampleData);
    void logTest(streamdalB, audienceBConsumer, exampleData);
    void logTest(streamdalB, audienceBProducer, exampleData);
    void logTest(streamdalB, Object.assign(Object.assign({}, audienceBProducer), { operationName: "kafka-producer-two" }), exampleData);
});
exports.exampleMultipleGroup = exampleMultipleGroup;
// eslint-disable-next-line @typescript-eslint/require-await
const exampleMultipleComponentsPerService = () => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalA = new streamdal_js_1.Streamdal(serviceAConfig);
    const streamdalB = new streamdal_js_1.Streamdal(serviceBConfig);
    void logTest(streamdalA, audienceAConsumer, exampleData);
    void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { componentName: "another-kafka" }), exampleData);
    void logTest(streamdalA, audienceAProducer, exampleData);
    void logTest(streamdalB, audienceBConsumer, exampleData);
    void logTest(streamdalB, audienceBProducer, exampleData);
    void logTest(streamdalB, Object.assign(Object.assign({}, audienceBProducer), { componentName: "kafka" }), exampleData);
});
exports.exampleMultipleComponentsPerService = exampleMultipleComponentsPerService;
// eslint-disable-next-line @typescript-eslint/require-await
const exampleSimple = () => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalA = new streamdal_js_1.Streamdal(serviceAConfig);
    void logTest(streamdalA, audienceAConsumer, exampleData);
});
exports.exampleSimple = exampleSimple;
const exampleStaggeredMultipleComponentsPerServiceAndPerGroup = 
// eslint-disable-next-line @typescript-eslint/require-await
() => __awaiter(void 0, void 0, void 0, function* () {
    const streamdalA = new streamdal_js_1.Streamdal(serviceAConfig);
    const streamdalB = new streamdal_js_1.Streamdal(serviceBConfig);
    const streamdalC = new streamdal_js_1.Streamdal(serviceCConfig);
    setInterval(() => {
        void logTest(streamdalA, audienceAConsumer, exampleData);
    }, 2000);
    setInterval(() => {
        void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { operationName: "kafka-consumer-two" }), exampleData);
    }, 4000);
    setInterval(() => {
        void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { operationName: "kafka-consumer-three" }), exampleData);
    }, 6000);
    setInterval(() => {
        void logTest(streamdalA, Object.assign(Object.assign({}, audienceAConsumer), { componentName: "another-kafka" }), exampleData);
    }, 8000);
    setInterval(() => {
        void logTest(streamdalA, audienceAProducer, exampleData);
    }, 10000);
    setInterval(() => {
        void logTest(streamdalB, audienceBConsumer, exampleData);
    }, 12000);
    setInterval(() => {
        void logTest(streamdalB, audienceBProducer, exampleData);
    }, 14000);
    setInterval(() => {
        void logTest(streamdalB, Object.assign(Object.assign({}, audienceBProducer), { componentName: "kafka" }), exampleData);
    }, 16000);
    setInterval(() => {
        void logTest(streamdalC, audienceCConsumer, exampleData);
    }, 2000);
    setInterval(() => {
        void logTest(streamdalC, audienceCProducer, exampleData);
    }, 2000);
});
exports.exampleStaggeredMultipleComponentsPerServiceAndPerGroup = exampleStaggeredMultipleComponentsPerServiceAndPerGroup;
void (0, exports.throughputFriendly)();
