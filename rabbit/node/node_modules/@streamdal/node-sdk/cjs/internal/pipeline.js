"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tailPipeline = exports.togglePausePipeline = exports.detachPipeline = exports.attachPipeline = exports.buildPipeline = exports.processResponse = exports.initPipelines = void 0;
const sp_common_1 = require("@streamdal/protos/protos/sp_common");
const register_js_1 = require("./register.js");
const initPipelines = (configs) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        console.debug("initializing pipelines");
        const { response } = yield configs.grpcClient.getAttachCommandsByService({
            serviceName: configs.serviceName.toLowerCase(),
        }, { meta: { "auth-token": configs.streamdalToken } });
        for (const [k, v] of Object.entries(response.wasmModules)) {
            register_js_1.internal.wasmModules.set(k, v);
        }
        for (const command of response.active) {
            (0, exports.processResponse)(command);
        }
        register_js_1.internal.pipelineInitialized = true;
    }
    catch (e) {
        console.error("Error initializing pipelines", e);
    }
});
exports.initPipelines = initPipelines;
const processResponse = (response) => {
    if (!response.audience) {
        response.command.oneofKind !== "keepAlive" &&
            console.debug("command response has no audience, ignoring");
        return;
    }
    switch (response.command.oneofKind) {
        case "attachPipeline":
            response.command.attachPipeline.pipeline &&
                (0, exports.attachPipeline)(response.audience, response.command.attachPipeline.pipeline);
            break;
        case "detachPipeline":
            (0, exports.detachPipeline)(response.audience, response.command.detachPipeline.pipelineId);
            break;
        case "pausePipeline":
            (0, exports.togglePausePipeline)(response.audience, response.command.pausePipeline.pipelineId, true);
            break;
        case "resumePipeline":
            (0, exports.togglePausePipeline)(response.audience, response.command.resumePipeline.pipelineId, false);
            break;
        case "tail":
            (0, exports.tailPipeline)(response.audience, response.command.tail);
            break;
    }
};
exports.processResponse = processResponse;
const buildPipeline = (pipeline) => (Object.assign(Object.assign({}, pipeline), { steps: pipeline.steps.map((step) => {
        var _a;
        return (Object.assign(Object.assign({}, step), (step.WasmId
            ? { WasmBytes: (_a = register_js_1.internal.wasmModules.get(step.WasmId)) === null || _a === void 0 ? void 0 : _a.bytes }
            : {})));
    }) }));
exports.buildPipeline = buildPipeline;
const attachPipeline = (audience, pipeline) => pipeline.name !== "Schema Inference" &&
    register_js_1.internal.pipelines.set((0, register_js_1.audienceKey)(audience), Object.assign(Object.assign({}, (0, exports.buildPipeline)(pipeline)), { paused: false }));
exports.attachPipeline = attachPipeline;
const detachPipeline = (audience, pipelineId) => {
    const key = (0, register_js_1.audienceKey)(audience);
    const p = register_js_1.internal.pipelines.get(key);
    pipelineId === (p === null || p === void 0 ? void 0 : p.id) && register_js_1.internal.pipelines.delete(key);
};
exports.detachPipeline = detachPipeline;
const togglePausePipeline = (audience, pipelineId, paused) => {
    const key = (0, register_js_1.audienceKey)(audience);
    const p = register_js_1.internal.pipelines.get(key);
    pipelineId === (p === null || p === void 0 ? void 0 : p.id) && register_js_1.internal.pipelines.set(key, Object.assign(Object.assign({}, p), { paused }));
};
exports.togglePausePipeline = togglePausePipeline;
const tailPipeline = (audience, { request }) => {
    var _a, _b;
    console.debug("received a tail command for audience", audience);
    if (!request) {
        console.debug("no tail reqeuest details specified, skipping");
        return;
    }
    switch (request.type) {
        case sp_common_1.TailRequestType.START: {
            console.debug("received a START tail: adding entry to audiences for tail id", audience);
            // Create inner map if it doesn't exist
            if (!register_js_1.internal.audiences.has((0, register_js_1.audienceKey)(audience))) {
                register_js_1.internal.audiences.set((0, register_js_1.audienceKey)(audience), {
                    audience,
                    tails: new Map(),
                });
            }
            // Add entry (@JH, OK if overwritten?)
            request.Id &&
                ((_a = register_js_1.internal.audiences.get((0, register_js_1.audienceKey)(audience))) === null || _a === void 0 ? void 0 : _a.tails.set(request.Id, {
                    tail: request.type === sp_common_1.TailRequestType.START,
                    tailRequestId: request.Id,
                }));
            break;
        }
        case sp_common_1.TailRequestType.STOP: {
            console.debug("received a STOP tail: removing entry from audiences for tail id", request.Id);
            request.Id &&
                ((_b = register_js_1.internal.audiences.get((0, register_js_1.audienceKey)(audience))) === null || _b === void 0 ? void 0 : _b.tails.delete(request.Id));
            break;
        }
        default:
            console.error("unknown tail request type ", request.type);
            break;
    }
};
exports.tailPipeline = tailPipeline;
