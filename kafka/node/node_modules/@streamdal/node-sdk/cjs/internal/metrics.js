"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendMetrics = exports.audienceMetrics = exports.stepMetrics = exports.getStepLabels = exports.lock = exports.metrics = exports.METRIC_INTERVAL = void 0;
const sp_common_1 = require("@streamdal/protos/protos/sp_common");
const rwlock_1 = __importDefault(require("rwlock"));
exports.METRIC_INTERVAL = 1000;
exports.metrics = new Map();
exports.lock = new rwlock_1.default();
const getStepLabels = (audience, stepStatus) => ({
    service: audience.serviceName,
    component: audience.componentName,
    operation: audience.operationName,
    pipeline_id: stepStatus.pipelineId,
    pipeline_name: stepStatus.pipelineName,
});
exports.getStepLabels = getStepLabels;
const stepMetrics = (audience, stepStatus, payloadSize
// eslint-disable-next-line @typescript-eslint/require-await
) => __awaiter(void 0, void 0, void 0, function* () {
    exports.lock.writeLock((release) => {
        var _a, _b, _c, _d, _e, _f;
        const opName = audience.operationType === sp_common_1.OperationType.CONSUMER ? "consume" : "produce";
        const labels = (0, exports.getStepLabels)(audience, stepStatus);
        const stepErrorKey = `counter_${opName}_errors`;
        const stepProcessedKey = `counter_${opName}_processed`;
        const stepBytesKey = `counter_${opName}_bytes`;
        stepStatus.error &&
            exports.metrics.set(stepErrorKey, {
                name: stepErrorKey,
                value: ((_b = (_a = exports.metrics.get(stepErrorKey)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + 1,
                labels,
                audience,
            });
        exports.metrics.set(stepProcessedKey, {
            name: stepProcessedKey,
            value: ((_d = (_c = exports.metrics.get(stepProcessedKey)) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 0) + 1,
            labels,
            audience,
        });
        exports.metrics.set(stepBytesKey, {
            name: stepBytesKey,
            value: ((_f = (_e = exports.metrics.get(stepBytesKey)) === null || _e === void 0 ? void 0 : _e.value) !== null && _f !== void 0 ? _f : 0) + payloadSize,
            labels,
            audience,
        });
        release();
    });
});
exports.stepMetrics = stepMetrics;
const audienceMetrics = (audience, payloadSize
// eslint-disable-next-line @typescript-eslint/require-await
) => __awaiter(void 0, void 0, void 0, function* () {
    exports.lock.writeLock((release) => {
        var _a, _b, _c, _d;
        const opName = audience.operationType === sp_common_1.OperationType.CONSUMER ? "consume" : "produce";
        const bytesProcessedKey = `counter_${opName}_bytes_rate`;
        const processedKey = `counter_${opName}_processed_rate`;
        exports.metrics.set(bytesProcessedKey, {
            name: bytesProcessedKey,
            value: ((_b = (_a = exports.metrics.get(bytesProcessedKey)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + payloadSize,
            labels: {},
            audience,
        });
        exports.metrics.set(processedKey, {
            name: processedKey,
            value: ((_d = (_c = exports.metrics.get(processedKey)) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : 0) + 1,
            labels: {},
            audience,
        });
        release();
    });
});
exports.audienceMetrics = audienceMetrics;
const sendMetrics = (configs) => exports.lock.writeLock((release) => {
    try {
        if (!exports.metrics.size) {
            console.debug(`### no metrics found, skipping`);
            release();
            return;
        }
        const metricsData = Array.from(exports.metrics.values()).map((m) => (Object.assign(Object.assign({}, m), { 
            //
            // Make sure we always send data per second
            value: m.value / (exports.METRIC_INTERVAL / 1000) })));
        console.debug("sending metrics", metricsData);
        void configs.grpcClient.metrics({
            metrics: metricsData,
        }, { meta: { "auth-token": configs.streamdalToken } });
        exports.metrics.clear();
    }
    catch (e) {
        console.error("error sending metrics", e);
    }
    release();
});
exports.sendMetrics = sendMetrics;
