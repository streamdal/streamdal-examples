"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWasm = exports.readResponse = void 0;
const sp_wsm_1 = require("@streamdal/protos/protos/sp_wsm");
// eslint-disable-next-line import/no-unresolved
const wasi_1 = require("wasi");
const [nodeVersionMajor] = process.versions.node.split(".");
const wasi = new wasi_1.WASI(Object.assign(Object.assign({}, (Number(nodeVersionMajor) >= 20 ? { version: "preview1" } : {})), { preopens: {
        "/sandbox": "./",
    } }));
const readResponse = (pointer, buffer) => {
    let nullHits = 0;
    const data = [];
    for (let i = pointer; i < buffer.length; i++) {
        //
        // Have three nulls in a row, can quit
        if (nullHits === 3) {
            break;
        }
        // Don't have a length, have to see if we hit three sequential terminators
        if (buffer[i] === 166) {
            nullHits++;
            continue;
        }
        // Not a terminator, reset null hits
        nullHits = 0;
        data.push(buffer[i]);
    }
    return new Uint8Array(data);
};
exports.readResponse = readResponse;
const runWasm = ({ step, data, }) => __awaiter(void 0, void 0, void 0, function* () {
    if (!step.WasmBytes || !step.WasmFunction) {
        throw Error(`No wasm function found for step ${step.name}`);
    }
    const wasm = yield WebAssembly.compile(step.WasmBytes);
    const importObject = { wasi_snapshot_preview1: wasi.wasiImport };
    const instance = yield WebAssembly.instantiate(wasm, importObject);
    const { exports } = instance;
    const { memory, alloc, [step.WasmFunction]: f } = exports;
    const request = sp_wsm_1.WASMRequest.create({
        step: {
            name: step.name,
            onSuccess: step.onSuccess,
            onFailure: step.onFailure,
            step: step.step,
        },
        inputPayload: data,
    });
    const requestBytes = sp_wsm_1.WASMRequest.toBinary(request);
    const ptr = alloc(requestBytes.length);
    const mem = new Uint8Array(memory.buffer, ptr, requestBytes.length);
    mem.set(requestBytes);
    const returnPtr = f(ptr, requestBytes.length);
    const completeBufferFromMemory = new Uint8Array(memory.buffer);
    const response = (0, exports.readResponse)(returnPtr, completeBufferFromMemory);
    const decodedResponse = sp_wsm_1.WASMResponse.fromBinary(response);
    return decodedResponse;
});
exports.runWasm = runWasm;
