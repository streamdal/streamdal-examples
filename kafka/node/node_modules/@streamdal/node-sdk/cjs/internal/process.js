"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runStep = exports.resultCondition = exports.processPipeline = exports.retryProcessPipeline = exports.sendTail = void 0;
const sp_common_1 = require("@streamdal/protos/protos/sp_common");
const sp_pipeline_1 = require("@streamdal/protos/protos/sp_pipeline");
const sp_wsm_1 = require("@streamdal/protos/protos/sp_wsm");
const audience_js_1 = require("./audience.js");
const metrics_js_1 = require("./metrics.js");
const pipeline_js_1 = require("./pipeline.js");
const register_js_1 = require("./register.js");
const wasm_js_1 = require("./wasm.js");
const MAX_PAYLOAD_SIZE = 1024 * 1024; // 1 megabyte
const MAX_PIPELINE_RETRIES = 10;
const PIPELINE_RETRY_INTERVAL = 1000;
//
// add pipeline information to the steps so we can log/notify
// appropriately as we go
const mapAllSteps = (pipeline) => pipeline.steps.map((s) => (Object.assign(Object.assign({}, s), { pipelineId: pipeline.id, pipelineName: pipeline.name })));
const sendTail = ({ configs, tails, audience, originalData, newData, }) => {
    try {
        const tailCall = configs.grpcClient.sendTail({
            meta: { "auth-token": configs.streamdalToken },
        });
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        tails === null || tails === void 0 ? void 0 : tails.forEach((tailStatus, tailRequestId) => __awaiter(void 0, void 0, void 0, function* () {
            if (tailStatus.tail) {
                const tailResponse = sp_common_1.TailResponse.create({
                    timestampNs: (BigInt(new Date().getTime()) * BigInt(1e6)).toString(),
                    type: sp_common_1.TailResponseType.PAYLOAD,
                    tailRequestId: tailRequestId,
                    audience,
                    sessionId: configs.sessionId,
                    originalData,
                    newData,
                });
                console.debug("sending tail response", tailResponse);
                yield tailCall.requests.send(tailResponse);
                const headers = yield tailCall.headers;
                console.debug("got tail response headers: ", headers);
                const response = yield tailCall.response;
                console.debug("got tail response message: ", response);
                const status = yield tailCall.status;
                console.debug("got tail status: ", status);
                const trailers = yield tailCall.trailers;
                console.debug("got tail trailers: ", trailers);
            }
        }));
    }
    catch (e) {
        console.error("Error sending tail request", e);
    }
};
exports.sendTail = sendTail;
const retryProcessPipeline = ({ configs, audience, data, }) => __awaiter(void 0, void 0, void 0, function* () {
    let retries = 1;
    try {
        if (register_js_1.internal.registered) {
            return (0, exports.processPipeline)({
                configs,
                audience,
                data,
            });
        }
        console.info(`not yet registered with the grpc server, retrying process pipeline in ${PIPELINE_RETRY_INTERVAL / 1000} seconds...`);
        return new Promise((resolve) => {
            const intervalId = setInterval(() => {
                retries++;
                if (MAX_PIPELINE_RETRIES && retries >= MAX_PIPELINE_RETRIES) {
                    clearInterval(intervalId);
                    return;
                }
                if (register_js_1.internal.registered) {
                    console.debug(`retrying process pipeline...`);
                    clearInterval(intervalId);
                    return resolve((0, exports.processPipeline)({
                        configs,
                        audience,
                        data,
                    }));
                }
                console.debug(`retrying process pipeline in ${PIPELINE_RETRY_INTERVAL / 1000} seconds; ${retries} of ${MAX_PIPELINE_RETRIES} retries`);
            }, PIPELINE_RETRY_INTERVAL);
        });
    }
    catch (e) {
        console.error("Error running process pipeline", e);
    }
    const message = "Node SDK not registered with the server, skipping pipeline. Is the server running?";
    console.error(message);
    return Promise.resolve({
        data,
        error: true,
        message,
    });
});
exports.retryProcessPipeline = retryProcessPipeline;
const processPipeline = ({ configs, audience, data, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    if (!register_js_1.internal.pipelineInitialized) {
        yield (0, pipeline_js_1.initPipelines)(configs);
    }
    yield (0, audience_js_1.addAudience)({ configs: configs, audience });
    const key = (0, register_js_1.audienceKey)(audience);
    const pipeline = register_js_1.internal.pipelines.get(key);
    const tails = (_a = register_js_1.internal.audiences.get(key)) === null || _a === void 0 ? void 0 : _a.tails;
    void (0, metrics_js_1.audienceMetrics)(audience, data.length);
    if (!pipeline || pipeline.paused) {
        const message = "no active pipeline found for this audience, returning data";
        console.debug(message);
        (0, exports.sendTail)({
            configs,
            tails,
            audience,
            originalData: data,
        });
        return { data, error: true, message };
    }
    //
    // hold for tail
    const originalData = data;
    const allSteps = mapAllSteps(pipeline);
    //
    // wrapping data up in a status object so we can track
    // statuses pass along updated data from step to step
    let pipelineStatus = {
        data,
        stepStatuses: [],
    };
    for (const step of allSteps) {
        if (configs.dryRun) {
            console.debug(`Dry run set. Found pipeline step ${step.pipelineName} - ${step.name}...not running.`);
            continue;
        }
        console.debug(`running pipeline step ${step.pipelineName} - ${step.name}...`);
        pipelineStatus = yield (0, exports.runStep)({
            audience,
            configs,
            step,
            pipeline: pipelineStatus,
        });
        console.debug(`pipeline step ${step.pipelineName} - ${step.name} complete`);
        if ((_b = pipelineStatus.stepStatuses.at(-1)) === null || _b === void 0 ? void 0 : _b.abort) {
            break;
        }
    }
    (0, exports.sendTail)({
        configs,
        tails,
        audience,
        originalData,
        newData: data,
    });
    //
    // For now top level response status is synonymous with the last step status
    const finalStatus = pipelineStatus.stepStatuses.at(-1);
    return Object.assign(Object.assign({}, pipelineStatus), { error: !!(finalStatus === null || finalStatus === void 0 ? void 0 : finalStatus.error), message: (_c = finalStatus === null || finalStatus === void 0 ? void 0 : finalStatus.message) !== null && _c !== void 0 ? _c : "Success" });
});
exports.processPipeline = processPipeline;
const notifyStep = (configs, step) => __awaiter(void 0, void 0, void 0, function* () {
    console.debug("notifying error step", step);
    try {
        yield configs.grpcClient.notify({
            pipelineId: step.pipelineId,
            stepName: step.stepName,
            occurredAtUnixTsUtc: Date.now().toString(),
        }, { meta: { "auth-token": configs.streamdalToken } });
    }
    catch (e) {
        console.error("error sending notification to server", e);
    }
});
const resultCondition = (configs, conditions, stepStatus) => {
    if (conditions.includes(sp_pipeline_1.PipelineStepCondition.NOTIFY)) {
        void notifyStep(configs, stepStatus);
    }
    if (conditions.includes(sp_pipeline_1.PipelineStepCondition.ABORT)) {
        stepStatus.abort = true;
    }
};
exports.resultCondition = resultCondition;
const runStep = ({ audience, configs, step, pipeline, }) => __awaiter(void 0, void 0, void 0, function* () {
    const stepStatus = {
        stepName: step.name,
        pipelineId: step.pipelineId,
        pipelineName: step.pipelineName,
        error: false,
        abort: false,
    };
    let data = pipeline.data;
    const payloadSize = data.length;
    try {
        const { outputPayload, exitCode, exitMsg } = payloadSize < MAX_PAYLOAD_SIZE
            ? yield (0, wasm_js_1.runWasm)({
                step,
                data,
            })
            : {
                outputPayload: new Uint8Array(),
                exitCode: sp_wsm_1.WASMExitCode.WASM_EXIT_CODE_FAILURE,
                exitMsg: "Payload exceeds maximum size",
            };
        //
        // output gets passed back as data for the next function
        data =
            exitCode === sp_wsm_1.WASMExitCode.WASM_EXIT_CODE_SUCCESS ? outputPayload : data;
        stepStatus.error = exitCode !== sp_wsm_1.WASMExitCode.WASM_EXIT_CODE_SUCCESS;
        stepStatus.message = exitMsg;
    }
    catch (error) {
        stepStatus.error = true;
        stepStatus.message = error.toString();
        stepStatus.abort = true;
    }
    (0, exports.resultCondition)(configs, stepStatus.error ? step.onFailure : step.onSuccess, stepStatus);
    void (0, metrics_js_1.stepMetrics)(audience, stepStatus, payloadSize);
    return { data, stepStatuses: [...pipeline.stepStatuses, stepStatus] };
});
exports.runStep = runStep;
