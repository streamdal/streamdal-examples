var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { TailResponse, TailResponseType, } from "@streamdal/protos/protos/sp_common";
import { PipelineStepCondition, } from "@streamdal/protos/protos/sp_pipeline";
import { WASMExitCode } from "@streamdal/protos/protos/sp_wsm";
import { addAudience } from "./audience.js";
import { audienceMetrics, stepMetrics } from "./metrics.js";
import { initPipelines } from "./pipeline.js";
import { audienceKey, internal } from "./register.js";
import { runWasm } from "./wasm.js";
const MAX_PAYLOAD_SIZE = 1024 * 1024; // 1 megabyte
const MAX_PIPELINE_RETRIES = 10;
const PIPELINE_RETRY_INTERVAL = 1000;
//
// add pipeline information to the steps so we can log/notify
// appropriately as we go
const mapAllSteps = (pipeline) => pipeline.steps.map((s) => (Object.assign(Object.assign({}, s), { pipelineId: pipeline.id, pipelineName: pipeline.name })));
export const sendTail = ({ configs, tails, audience, originalData, newData, }) => {
    try {
        const tailCall = configs.grpcClient.sendTail({
            meta: { "auth-token": configs.streamdalToken },
        });
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        tails === null || tails === void 0 ? void 0 : tails.forEach((tailStatus, tailRequestId) => __awaiter(void 0, void 0, void 0, function* () {
            if (tailStatus.tail) {
                const tailResponse = TailResponse.create({
                    timestampNs: (BigInt(new Date().getTime()) * BigInt(1e6)).toString(),
                    type: TailResponseType.PAYLOAD,
                    tailRequestId: tailRequestId,
                    audience,
                    sessionId: configs.sessionId,
                    originalData,
                    newData,
                });
                console.debug("sending tail response", tailResponse);
                yield tailCall.requests.send(tailResponse);
                const headers = yield tailCall.headers;
                console.debug("got tail response headers: ", headers);
                const response = yield tailCall.response;
                console.debug("got tail response message: ", response);
                const status = yield tailCall.status;
                console.debug("got tail status: ", status);
                const trailers = yield tailCall.trailers;
                console.debug("got tail trailers: ", trailers);
            }
        }));
    }
    catch (e) {
        console.error("Error sending tail request", e);
    }
};
export const retryProcessPipeline = ({ configs, audience, data, }) => __awaiter(void 0, void 0, void 0, function* () {
    let retries = 1;
    try {
        if (internal.registered) {
            return processPipeline({
                configs,
                audience,
                data,
            });
        }
        console.info(`not yet registered with the grpc server, retrying process pipeline in ${PIPELINE_RETRY_INTERVAL / 1000} seconds...`);
        return new Promise((resolve) => {
            const intervalId = setInterval(() => {
                retries++;
                if (MAX_PIPELINE_RETRIES && retries >= MAX_PIPELINE_RETRIES) {
                    clearInterval(intervalId);
                    return;
                }
                if (internal.registered) {
                    console.debug(`retrying process pipeline...`);
                    clearInterval(intervalId);
                    return resolve(processPipeline({
                        configs,
                        audience,
                        data,
                    }));
                }
                console.debug(`retrying process pipeline in ${PIPELINE_RETRY_INTERVAL / 1000} seconds; ${retries} of ${MAX_PIPELINE_RETRIES} retries`);
            }, PIPELINE_RETRY_INTERVAL);
        });
    }
    catch (e) {
        console.error("Error running process pipeline", e);
    }
    const message = "Node SDK not registered with the server, skipping pipeline. Is the server running?";
    console.error(message);
    return Promise.resolve({
        data,
        error: true,
        message,
    });
});
export const processPipeline = ({ configs, audience, data, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    if (!internal.pipelineInitialized) {
        yield initPipelines(configs);
    }
    yield addAudience({ configs: configs, audience });
    const key = audienceKey(audience);
    const pipeline = internal.pipelines.get(key);
    const tails = (_a = internal.audiences.get(key)) === null || _a === void 0 ? void 0 : _a.tails;
    void audienceMetrics(audience, data.length);
    if (!pipeline || pipeline.paused) {
        const message = "no active pipeline found for this audience, returning data";
        console.debug(message);
        sendTail({
            configs,
            tails,
            audience,
            originalData: data,
        });
        return { data, error: true, message };
    }
    //
    // hold for tail
    const originalData = data;
    const allSteps = mapAllSteps(pipeline);
    //
    // wrapping data up in a status object so we can track
    // statuses pass along updated data from step to step
    let pipelineStatus = {
        data,
        stepStatuses: [],
    };
    for (const step of allSteps) {
        if (configs.dryRun) {
            console.debug(`Dry run set. Found pipeline step ${step.pipelineName} - ${step.name}...not running.`);
            continue;
        }
        console.debug(`running pipeline step ${step.pipelineName} - ${step.name}...`);
        pipelineStatus = yield runStep({
            audience,
            configs,
            step,
            pipeline: pipelineStatus,
        });
        console.debug(`pipeline step ${step.pipelineName} - ${step.name} complete`);
        if ((_b = pipelineStatus.stepStatuses.at(-1)) === null || _b === void 0 ? void 0 : _b.abort) {
            break;
        }
    }
    sendTail({
        configs,
        tails,
        audience,
        originalData,
        newData: data,
    });
    //
    // For now top level response status is synonymous with the last step status
    const finalStatus = pipelineStatus.stepStatuses.at(-1);
    return Object.assign(Object.assign({}, pipelineStatus), { error: !!(finalStatus === null || finalStatus === void 0 ? void 0 : finalStatus.error), message: (_c = finalStatus === null || finalStatus === void 0 ? void 0 : finalStatus.message) !== null && _c !== void 0 ? _c : "Success" });
});
const notifyStep = (configs, step) => __awaiter(void 0, void 0, void 0, function* () {
    console.debug("notifying error step", step);
    try {
        yield configs.grpcClient.notify({
            pipelineId: step.pipelineId,
            stepName: step.stepName,
            occurredAtUnixTsUtc: Date.now().toString(),
        }, { meta: { "auth-token": configs.streamdalToken } });
    }
    catch (e) {
        console.error("error sending notification to server", e);
    }
});
export const resultCondition = (configs, conditions, stepStatus) => {
    if (conditions.includes(PipelineStepCondition.NOTIFY)) {
        void notifyStep(configs, stepStatus);
    }
    if (conditions.includes(PipelineStepCondition.ABORT)) {
        stepStatus.abort = true;
    }
};
export const runStep = ({ audience, configs, step, pipeline, }) => __awaiter(void 0, void 0, void 0, function* () {
    const stepStatus = {
        stepName: step.name,
        pipelineId: step.pipelineId,
        pipelineName: step.pipelineName,
        error: false,
        abort: false,
    };
    let data = pipeline.data;
    const payloadSize = data.length;
    try {
        const { outputPayload, exitCode, exitMsg } = payloadSize < MAX_PAYLOAD_SIZE
            ? yield runWasm({
                step,
                data,
            })
            : {
                outputPayload: new Uint8Array(),
                exitCode: WASMExitCode.WASM_EXIT_CODE_FAILURE,
                exitMsg: "Payload exceeds maximum size",
            };
        //
        // output gets passed back as data for the next function
        data =
            exitCode === WASMExitCode.WASM_EXIT_CODE_SUCCESS ? outputPayload : data;
        stepStatus.error = exitCode !== WASMExitCode.WASM_EXIT_CODE_SUCCESS;
        stepStatus.message = exitMsg;
    }
    catch (error) {
        stepStatus.error = true;
        stepStatus.message = error.toString();
        stepStatus.abort = true;
    }
    resultCondition(configs, stepStatus.error ? step.onFailure : step.onSuccess, stepStatus);
    void stepMetrics(audience, stepStatus, payloadSize);
    return { data, stepStatuses: [...pipeline.stepStatuses, stepStatus] };
});
